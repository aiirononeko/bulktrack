// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: volume.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestWeeklyVolume = `-- name: GetLatestWeeklyVolume :one
SELECT 
    id,
    user_id,
    week_start_date,
    total_volume,
    est_one_rm,
    exercise_count,
    set_count,
    created_at,
    updated_at
FROM weekly_volumes
WHERE user_id = $1::text
ORDER BY week_start_date DESC
LIMIT 1
`

// Get the most recent weekly volume for a user
func (q *Queries) GetLatestWeeklyVolume(ctx context.Context, userID string) (WeeklyVolume, error) {
	row := q.db.QueryRow(ctx, getLatestWeeklyVolume, userID)
	var i WeeklyVolume
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WeekStartDate,
		&i.TotalVolume,
		&i.EstOneRm,
		&i.ExerciseCount,
		&i.SetCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWeeklyVolumeByExercise = `-- name: GetWeeklyVolumeByExercise :many
SELECT 
    e.id AS exercise_id,
    e.name AS exercise_name,
    SUM(s.weight_kg * s.reps) AS total_volume,
    MAX(s.weight_kg * (1 + s.reps / 30.0)) AS est_one_rm,
    COUNT(s.id) AS set_count
FROM workouts w
JOIN sets s ON w.id = s.workout_id
JOIN exercises e ON s.exercise_id = e.id
WHERE 
    w.user_id = $1::text AND
    get_jst_week_start(w.started_at) = $2::date
GROUP BY e.id, e.name
ORDER BY total_volume DESC
`

type GetWeeklyVolumeByExerciseParams struct {
	UserID        string      `json:"user_id"`
	WeekStartDate pgtype.Date `json:"week_start_date"`
}

type GetWeeklyVolumeByExerciseRow struct {
	ExerciseID   uuid.UUID   `json:"exercise_id"`
	ExerciseName string      `json:"exercise_name"`
	TotalVolume  int64       `json:"total_volume"`
	EstOneRm     interface{} `json:"est_one_rm"`
	SetCount     int64       `json:"set_count"`
}

// Get weekly volumes broken down by exercise for a specific user and week
func (q *Queries) GetWeeklyVolumeByExercise(ctx context.Context, arg GetWeeklyVolumeByExerciseParams) ([]GetWeeklyVolumeByExerciseRow, error) {
	rows, err := q.db.Query(ctx, getWeeklyVolumeByExercise, arg.UserID, arg.WeekStartDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWeeklyVolumeByExerciseRow{}
	for rows.Next() {
		var i GetWeeklyVolumeByExerciseRow
		if err := rows.Scan(
			&i.ExerciseID,
			&i.ExerciseName,
			&i.TotalVolume,
			&i.EstOneRm,
			&i.SetCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyVolumeByMuscleGroup = `-- name: GetWeeklyVolumeByMuscleGroup :many
SELECT 
    mg.id AS muscle_group_id,
    mg.name AS muscle_group_name,
    SUM(s.weight_kg * s.reps) AS total_volume,
    COUNT(DISTINCT e.id) AS exercise_count,
    COUNT(s.id) AS set_count
FROM workouts w
JOIN sets s ON w.id = s.workout_id
JOIN exercises e ON s.exercise_id = e.id
JOIN exercise_target_muscle_groups etmg ON e.id = etmg.exercise_id
JOIN muscle_groups mg ON etmg.muscle_group_id = mg.id
WHERE 
    w.user_id = $1::text AND
    get_jst_week_start(w.started_at) = $2::date
GROUP BY mg.id, mg.name
ORDER BY total_volume DESC
`

type GetWeeklyVolumeByMuscleGroupParams struct {
	UserID        string      `json:"user_id"`
	WeekStartDate pgtype.Date `json:"week_start_date"`
}

type GetWeeklyVolumeByMuscleGroupRow struct {
	MuscleGroupID   uuid.UUID `json:"muscle_group_id"`
	MuscleGroupName string    `json:"muscle_group_name"`
	TotalVolume     int64     `json:"total_volume"`
	ExerciseCount   int64     `json:"exercise_count"`
	SetCount        int64     `json:"set_count"`
}

// Get weekly volumes broken down by muscle group for a specific user and week
func (q *Queries) GetWeeklyVolumeByMuscleGroup(ctx context.Context, arg GetWeeklyVolumeByMuscleGroupParams) ([]GetWeeklyVolumeByMuscleGroupRow, error) {
	rows, err := q.db.Query(ctx, getWeeklyVolumeByMuscleGroup, arg.UserID, arg.WeekStartDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWeeklyVolumeByMuscleGroupRow{}
	for rows.Next() {
		var i GetWeeklyVolumeByMuscleGroupRow
		if err := rows.Scan(
			&i.MuscleGroupID,
			&i.MuscleGroupName,
			&i.TotalVolume,
			&i.ExerciseCount,
			&i.SetCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyVolumeForWeek = `-- name: GetWeeklyVolumeForWeek :one
SELECT 
    id,
    user_id,
    week_start_date,
    total_volume,
    est_one_rm,
    exercise_count,
    set_count,
    created_at,
    updated_at
FROM weekly_volumes
WHERE 
    user_id = $1::text AND 
    week_start_date = $2::date
LIMIT 1
`

type GetWeeklyVolumeForWeekParams struct {
	UserID        string      `json:"user_id"`
	WeekStartDate pgtype.Date `json:"week_start_date"`
}

// Get weekly volume for a specific user and week
func (q *Queries) GetWeeklyVolumeForWeek(ctx context.Context, arg GetWeeklyVolumeForWeekParams) (WeeklyVolume, error) {
	row := q.db.QueryRow(ctx, getWeeklyVolumeForWeek, arg.UserID, arg.WeekStartDate)
	var i WeeklyVolume
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WeekStartDate,
		&i.TotalVolume,
		&i.EstOneRm,
		&i.ExerciseCount,
		&i.SetCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWeeklyVolumeStats = `-- name: GetWeeklyVolumeStats :one
SELECT 
    AVG(total_volume) AS avg_weekly_volume,
    MAX(total_volume) AS max_weekly_volume,
    MIN(total_volume) AS min_weekly_volume,
    MAX(est_one_rm) AS max_est_one_rm,
    AVG(exercise_count) AS avg_exercise_count,
    AVG(set_count) AS avg_set_count
FROM weekly_volumes
WHERE 
    user_id = $1::text AND
    week_start_date >= $2::date AND
    week_start_date <= $3::date
`

type GetWeeklyVolumeStatsParams struct {
	UserID    string      `json:"user_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetWeeklyVolumeStatsRow struct {
	AvgWeeklyVolume  float64     `json:"avg_weekly_volume"`
	MaxWeeklyVolume  interface{} `json:"max_weekly_volume"`
	MinWeeklyVolume  interface{} `json:"min_weekly_volume"`
	MaxEstOneRm      interface{} `json:"max_est_one_rm"`
	AvgExerciseCount float64     `json:"avg_exercise_count"`
	AvgSetCount      float64     `json:"avg_set_count"`
}

// Get statistics about weekly volumes for a user
func (q *Queries) GetWeeklyVolumeStats(ctx context.Context, arg GetWeeklyVolumeStatsParams) (GetWeeklyVolumeStatsRow, error) {
	row := q.db.QueryRow(ctx, getWeeklyVolumeStats, arg.UserID, arg.StartDate, arg.EndDate)
	var i GetWeeklyVolumeStatsRow
	err := row.Scan(
		&i.AvgWeeklyVolume,
		&i.MaxWeeklyVolume,
		&i.MinWeeklyVolume,
		&i.MaxEstOneRm,
		&i.AvgExerciseCount,
		&i.AvgSetCount,
	)
	return i, err
}

const getWeeklyVolumes = `-- name: GetWeeklyVolumes :many
SELECT 
    dates.week_start_date,
    COALESCE(wv.total_volume, 0)::NUMERIC AS total_volume,
    COALESCE(wv.est_one_rm, 0) AS est_one_rm,
    COALESCE(wv.exercise_count, 0) AS exercise_count,
    COALESCE(wv.set_count, 0) AS set_count
FROM (
    -- Generate a series of dates for the last N weeks
    SELECT 
        generate_series(
            -- Start from N weeks ago (Monday)
            date_trunc('week', (CURRENT_DATE AT TIME ZONE 'Asia/Tokyo') - ($1::int * interval '1 week'))::date,
            -- End at current week (Monday)
            date_trunc('week', CURRENT_DATE AT TIME ZONE 'Asia/Tokyo')::date,
            -- Weekly interval
            interval '1 week'
        )::DATE AS week_start_date
) dates
LEFT JOIN weekly_volumes wv ON 
    wv.week_start_date = dates.week_start_date AND 
    wv.user_id = $2::text
ORDER BY dates.week_start_date
`

type GetWeeklyVolumesParams struct {
	WeeksCount int32  `json:"weeks_count"`
	UserID     string `json:"user_id"`
}

type GetWeeklyVolumesRow struct {
	WeekStartDate pgtype.Date    `json:"week_start_date"`
	TotalVolume   pgtype.Numeric `json:"total_volume"`
	EstOneRm      pgtype.Numeric `json:"est_one_rm"`
	ExerciseCount int32          `json:"exercise_count"`
	SetCount      int32          `json:"set_count"`
}

// Get weekly volumes for a user for the specified number of weeks
// Returns data for the last N weeks, filling in zeros for weeks with no data
func (q *Queries) GetWeeklyVolumes(ctx context.Context, arg GetWeeklyVolumesParams) ([]GetWeeklyVolumesRow, error) {
	rows, err := q.db.Query(ctx, getWeeklyVolumes, arg.WeeksCount, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWeeklyVolumesRow{}
	for rows.Next() {
		var i GetWeeklyVolumesRow
		if err := rows.Scan(
			&i.WeekStartDate,
			&i.TotalVolume,
			&i.EstOneRm,
			&i.ExerciseCount,
			&i.SetCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recalculateWeeklyVolume = `-- name: RecalculateWeeklyVolume :exec
WITH volume_data AS (
    SELECT 
        w.user_id,
        get_jst_week_start(w.started_at) AS week_start_date,
        SUM(s.weight_kg * s.reps) AS total_volume,
        MAX(s.weight_kg * (1 + s.reps / 30.0)) AS est_one_rm,
        COUNT(DISTINCT s.exercise_id) AS exercise_count,
        COUNT(s.id) AS set_count
    FROM workouts w
    JOIN sets s ON w.id = s.workout_id
    WHERE 
        w.user_id = $1::text AND
        get_jst_week_start(w.started_at) = $2::date
    GROUP BY w.user_id, week_start_date
)
INSERT INTO weekly_volumes (
    user_id,
    week_start_date,
    total_volume,
    est_one_rm,
    exercise_count,
    set_count
)
SELECT 
    $1::text,
    $2::date,
    COALESCE(vd.total_volume, 0),
    COALESCE(vd.est_one_rm, 0),
    COALESCE(vd.exercise_count, 0),
    COALESCE(vd.set_count, 0)
FROM (SELECT 1) AS dummy
LEFT JOIN volume_data vd ON true
ON CONFLICT (user_id, week_start_date) 
DO UPDATE SET
    total_volume = EXCLUDED.total_volume,
    est_one_rm = EXCLUDED.est_one_rm,
    exercise_count = EXCLUDED.exercise_count,
    set_count = EXCLUDED.set_count,
    updated_at = now()
`

type RecalculateWeeklyVolumeParams struct {
	UserID        string      `json:"user_id"`
	WeekStartDate pgtype.Date `json:"week_start_date"`
}

// Manually recalculate weekly volume for a specific user and week
func (q *Queries) RecalculateWeeklyVolume(ctx context.Context, arg RecalculateWeeklyVolumeParams) error {
	_, err := q.db.Exec(ctx, recalculateWeeklyVolume, arg.UserID, arg.WeekStartDate)
	return err
}
